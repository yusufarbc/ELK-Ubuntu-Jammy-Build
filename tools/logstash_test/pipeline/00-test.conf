input {
  file {
    path => "/samples/*"
    start_position => "beginning"
    sincedb_path => "/tmp/sincedb_test"
    codec => plain { charset => "UTF-8" }
  }
}

filter {
  ########################################
  # JSON parse if the message is JSON
  ########################################
  if [message] =~ /^\s*\{/ {
    json { source => "message" target => "parsed_json" skip_on_invalid_json => true }
    if [parsed_json] {
      mutate {
        add_field => { "event.module" => "kaspersky" "event.dataset" => "kaspersky.av" }
        rename => { "[parsed_json][ComputerName]" => "[host][name]" }
      }
      # move threat name
      if [parsed_json][ThreatName] { mutate { rename => { "[parsed_json][ThreatName]" => "[threat][name]" } } }
      if [parsed_json][ThreatSeverity] { mutate { rename => { "[parsed_json][ThreatSeverity]" => "[threat][severity]" } } }
    }
  }

  ########################################
  # Cisco ASA parsing: look for %ASA- tags
  ########################################
  if [message] =~ /%ASA-/ {
    grok {
      match => { "message" => ["%{SYSLOGTIMESTAMP:syslog_timestamp} %{HOSTNAME:syslog_hostname} %%ASA-%{DATA:asa_code}: Built %{WORD:asa_direction} %{WORD:network.transport} connection %{INT:asa_conn_id} for (?:%{DATA:asa_iniface}:)?%{IP:source.ip}/%{INT:source.port} to (?:%{DATA:asa_outiface}:)?%{IP:destination.ip}/%{INT:destination.port}", "%{GREEDYDATA:syslog_message}" ] }
      tag_on_failure => ["_grok_asa_test_failure"]
    }
    date { match => ["syslog_timestamp","MMM dd HH:mm:ss","MMM  d HH:mm:ss"] timezone => "UTC" }
    mutate { add_field => { "event.dataset" => "cisco.asa" "event.module" => "cisco_asa" } }
  }

  ########################################
  # FortiGate kv parsing
  ########################################
  if [message] =~ /srcip=|dstip=|action=/ {
    kv {
      source => "message"
      field_split => "\s+"
      value_split => "="
      trim_key => "\s"
      trim_value => "\s\"\'"
    }
    mutate {
      if [srcip] { rename => { "srcip" => "source.ip" } }
      if [srcport] { rename => { "srcport" => "source.port" } }
      if [dstip] { rename => { "dstip" => "destination.ip" } }
      if [dstport] { rename => { "dstport" => "destination.port" } }
      add_field => { "event.module" => "fortigate" "event.dataset" => "fortigate.firewall" }
    }
  }

  ########################################
  # Generic fallback grok to capture remaining message
  ########################################
  if ![parsed_json] and ![source][ip] and ![destination][ip] {
    grok {
      match => { "message" => ["%{SYSLOGTIMESTAMP:syslog_timestamp} %{HOSTNAME:syslog_hostname} %{GREEDYDATA:syslog_message}", "%{GREEDYDATA:syslog_message}"] }
      tag_on_failure => ["_grok_fallback_failure"]
    }
    date { match => ["syslog_timestamp","MMM dd HH:mm:ss","MMM  d HH:mm:ss","ISO8601"] timezone => "UTC" }
    mutate { rename => { "syslog_hostname" => "host.name" } }
  }

}

output {
  file { path => "/usr/share/logstash/test-output/output.json" codec => json_lines }
  stdout { codec => rubydebug }
}
